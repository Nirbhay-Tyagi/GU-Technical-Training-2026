<h1>Sorting visualiser</h1>
<br>
<h2>Introduction</h2>
<br>
<p>Sorting is a fundamental operation in computer science that arranges elements in a specific order, typically ascending or descending. The Sorting Visualizer helps users understand how different sorting algorithms work by providing a step-by-step visual representation.</p>
<br>
<h2>Sorting Algorithms Implemented<h2>
<br>


<p>This project supports multiple sorting algorithms, each with unique characteristics:<p>
<br>

<h3>1. Bubble Sort</h3>
<br>
<p>Concept: Compares adjacent elements and swaps them if they are in the wrong order. This process continues until the array is sorted.<p>
<br>
<h3>Time Complexity:<h3>
<br>
<h4>Best Case: <h4>ùëÇ(ùëõ)(Already sorted)
<br>
Worst/Average Case: O(n2)
<br>


Space Complexity: O(1) (In-place sorting)
<br>

<p>Use Case: Educational purposes due to its simplicity.</p>
<br>
<h3>2. Selection Sort</h3>
<br>
<h3>Concept:<h3><p> Finds the smallest element in the array and swaps it with the first unsorted element. Repeats for the remaining elements.</p>
<br>
<h3>Time Complexity:<h3>
<br>
<h3>Best/Worst/Average Case:</h3> O(n2)
<br>

<h3>Space Complexity:</h3> O(1)
<br>

<h3>Use Case: Suitable for small datasets.</h3>
<br>
<h3>3. Insertion Sort</h3>
<br>
<h4>Concept:</h4> <p>Builds the sorted array one element at a time by inserting elements in their correct positions.</p>
<br>
Time Complexity:
<br>
Best Case: O(n) (Already sorted)
<br>



Space Complexity: O(1)
<br>


<h4>Use Case:</h4><p> Useful for nearly sorted or small datasets.</p>
<br>
<h3>4. Merge Sort</h3>
<br>
<h4>Concept:</h4> <p>Uses a divide-and-conquer approach. The array is split into two halves, sorted recursively, and merged back.</p>
<br>
<h4>Time Complexity:</h4>
<br>
<h4>Best/Worst/Average Case: </h4>O(nlogn)
<br>


<h4>Space Complexity: </h4>O(n) (Uses extra space for merging)
<br>


<h4>Use Case: </h4><p>Efficient for large datasets.</p>
<br>
<h3>5. Quick Sort</h3>
<br>
<h4>Concept: </h4><p>Picks a pivot, partitions the array so that smaller elements are on one side and larger ones on the other, then sorts recursively.</p>
<br>
<h4>Time Complexity:</h4>
<br>
<h4>Best/Average Case: </h4>O(nlogn)
<br>



Worst Case: O(n2)
<br>

Space Complexity: O(logn) 
<br>



<h4>Use Case:</h4> <p>Often preferred due to its high efficiency.</p>
<br>
<img src="sortingvisualiser.png" alt="sorting visualizer">

<h2>Project Features</h2>
<br>
<h3>User Interaction:</h3> <p>Users can select sorting algorithms, adjust array size, and modify sorting speed.<p>
<br>
<h3>Real-time Visualization: <h3>Step-by-step animations show how sorting progresses.
<br>
<h3>Light/Dark Mode:</h3><p> Improves readability based on user preference.</p>
<br>
<h3>Random Array Generation:</h3<p> Users can generate new datasets for sorting experiments.<p>
<br>
<h3>Conclusion</h3>
<br>
<p>This Sorting Visualizer provides an interactive way to learn and compare sorting algorithms. It highlights the strengths and weaknesses of different approaches and helps users understand algorithm efficiency, time complexity, and real-world use cases.<p>
